"""
Modules for queries and user responses.

:TODO: OrdinalQuery classes will be implemented so that the library will include ordinal data, which was used for reward learning in:
    K. Li, M. Tucker, E. Biyik, E. Novoseller, J. W. Burdick, Y. Sui, D. Sadigh, Y. Yue, A. D. Ames;
    "ROIAL: Region of Interest Active Learning for Characterizing Exoskeleton Gait Preference Landscapes", ICRA'21.
"""
from typing import List, Union
from copy import deepcopy
import itertools
import numpy as np
import time

from aprel.basics import Trajectory, TrajectorySet


class Query:
    """
    一个抽象的父类，用于类型标注（typing）。
    
    “Query” 表示向用户提出的问题。
    """
    def __init__(self):
        # 初始化方法（构造函数），此处未执行任何初始化操作。
        # 通常在子类中会重写该方法来定义具体的查询内容。
        pass
        
    def copy(self):
        """返回当前 Query 对象的深拷贝。"""
        # deepcopy() 会递归地复制对象内部的所有属性，
        # 从而创建一个完全独立的新对象（修改副本不会影响原对象）。
        return deepcopy(self)
        
    def visualize(self, delay: float = 0.):
        """
        可视化该 Query，即向用户展示或询问问题。
        
        参数:
            delay (float): 每次轨迹可视化之间的等待时间（秒）。
        """
        # 该方法是抽象接口，表示子类必须实现自己的可视化逻辑。
        # 例如，在强化学习中，可能用于展示两条轨迹，
        # 让用户选择哪一条更符合他们的偏好。
        raise NotImplementedError


class QueryWithResponse:
    """
    An abstract parent class that is useful for typing.
    
    An instance of this class holds both the query and the user's response to that query.
    
    Parameters:
        query (Query): The query.
        
    Attributes:
        query (Query): The query.
    """
    def __init__(self, query: Query):
        self.query = query


class DemonstrationQuery(Query):
    """
    A demonstration query is one where the initial state is given to the user, and they are asked to control the robot.
    
    Although not practical for optimization, this class is defined for coherence with other query types.
    
    Parameters:
        initial_state (numpy.array): The initial state of the environment.
        
    Attributes:
        initial_state (numpy.array): The initial state of the environment.
    """
    def __init__(self, initial_state: np.array):
        super(DemonstrationQuery, self).__init__()
        self.initial_state = initial_state
        
        
class Demonstration(QueryWithResponse):
    """
    The trajectory generated by the DemonstrationQuery, along with the DemonstrationQuery that prompted the user
    with the initial state.
    
    For preference-based reward learning initialized with demonstrations, this class should be used (without
    actually querying the user). First, the demonstration should be collected as a :class:`.Trajectory`
    object. Then, a :class:`.Demonstration` instance should be created with this trajectory without specifying
    the query parameter, in which case it is automatically assigned as the initial state of the trajectory.
    
    Parameters:
        trajectory (Trajectory): The demonstrated trajectory.
        query (DemonstrationQuery): The query that led to the trajectory, i.e., the initial state of the trajectory.
        
    Attributes:
        trajectory (Trajectory): The demonstrated trajectory.
        features (numpy.array): The features of the demonstrated trajectory.
        
    Raises:
        AssertionError: if the initial state of the trajectory does not match with the query.
    """
    def __init__(self, trajectory: Trajectory, query: DemonstrationQuery = None):
        # It is not consistent to put the query as the second argument,
        # but let's keep it because the demonstrations are only passively collected.
        initial_state, _ = trajectory[0]
        if query is None:
            query = DemonstrationQuery(initial_state)
        else:
            assert(np.all(np.isclose(query.initial_state, initial_state))), 'Mismatch between the query and the response for the demonstration.'
        super(Demonstration, self).__init__(query)
        self.trajectory = trajectory
        self.features = trajectory.features


class PreferenceQuery(Query):
    """
    PreferenceQuery（偏好查询）类 —— 表示一种用户偏好查询。
    
    在这种查询中，用户会被展示多条轨迹（trajectories），并被要求选择他们最喜欢的一条。

    参数:
        slate (TrajectorySet 或 List[Trajectory]): 
            要展示给用户的轨迹集合（即“候选轨迹集”）。

    属性:
        K (int): 查询中包含的轨迹数量。
        response_set (numpy.array): 用户可能的回答集合（通常为 0 ~ K-1 的索引）。

    异常:
        AssertionError: 如果轨迹数量少于2条，则抛出异常。
    """
    def __init__(self, slate: Union[TrajectorySet, List[Trajectory]]):
        
        # 调用父类 Query 的构造函数（虽然父类中是空的，但这样做符合继承规范）
        super(PreferenceQuery, self).__init__()
        # 断言 slate 参数必须是 TrajectorySet 或 list 类型，
        # 否则抛出错误提示，说明输入类型不符合要求。
        assert isinstance(slate, TrajectorySet) or isinstance(slate, list), 'Query constructor requires a TrajectorySet object for the slate.'
        
        # 将 slate 传入属性设定器（setter），从而触发 slate.setter 的逻辑。
        self.slate = slate
        
         # 确保查询中至少有 2 条轨迹，否则没有“偏好选择”的意义。
        assert(self.K >= 2), 'Preference queries have to include at least 2 trajectories.'
    
    @property
    def slate(self) -> TrajectorySet:
        """返回当前查询中的轨迹集合（TrajectorySet 对象）。"""
        return self._slate
    
    @slate.setter
    def slate(self, new_slate: Union[TrajectorySet, List[Trajectory]]):
        """设置查询的轨迹集合（slate）。"""
        # 如果输入是 TrajectorySet，直接赋值；
        # 如果是列表（List[Trajectory]），则自动封装为 TrajectorySet 对象。
        self._slate = new_slate if isinstance(new_slate, TrajectorySet) else TrajectorySet(new_slate)

        # K 表示轨迹数量（TrajectorySet.size 返回集合中轨迹的数量）
        self.K = self._slate.size
        # 定义用户可选择的响应集合，例如若有 3 条轨迹，则为 [0, 1, 2]
        self.response_set = np.arange(self.K)
        
    def visualize(self, delay: float = 0.) -> int:
        """
        可视化该偏好查询，并交互式地让用户选择他们最喜欢的轨迹。

        参数:
            delay (float): 每次轨迹展示之间的等待时间（单位：秒）。

        返回:
            int: 用户选择的轨迹索引（即偏好响应）。
        """
        
        # 遍历每一条轨迹进行展示
        for i in range(self.K):
            print('Playing trajectory #' + str(i))
            
            # 播放之间的延时，用于让用户有时间观察每条轨迹
            time.sleep(delay)
            
            # 调用轨迹对象自身的可视化方法
            self.slate[i].visualize()
            
        # 初始化用户选择
        selection = None
        
        # 循环直到用户输入合法的数字
        while selection is None:
            
            # 提示用户输入他们认为“最好”的轨迹编号
            selection = input('Which trajectory is the best? Enter a number: [0-' + str(self.K-1) + ']: ')
            
            # 检查输入是否为整数，且是否在有效范围内
            if not isinteger(selection) or int(selection) not in self.response_set:
                
                # 若输入非法，则重置 selection 并重新询问
                selection = None
        
        # 返回用户选择的轨迹索引（转为整数类型）
        return int(selection)
            

class Preference(QueryWithResponse):
    """
    A Preference feedback.
    
    Contains the :class:`.PreferenceQuery` the user responded to and the response.
    
    Parameters:
        query (PreferenceQuery): The query for which the feedback was given.
        response (int): The response of the user to the query.
        
    Attributes:
        response (int): The response of the user to the query.
        
    Raises:
        AssertionError: if the response is not in the response set of the query.
    """
    def __init__(self, query: PreferenceQuery, response: int):
        super(Preference, self).__init__(query)
        assert(response in self.query.response_set), 'Response ' + str(response) + ' is out of bounds for a slate size of ' + str(self.query.K) + '.'
        self.response = response


class WeakComparisonQuery(Query):
    """
    A weak comparison query is one where the user is presented with two trajectories and asked for their favorite among
    them, but also given an option to say 'they are about equal'.
    
    Parameters:
        slate (TrajectorySet or List[Trajectory]): The set of trajectories that will be presented to the user.

    Attributes:
        K (int): The number of trajectories in the query. It is always equal to 2 and kept for consistency with 
            :class:`.PreferenceQuery` and :class:`.FullRankingQuery`.
        response_set (numpy.array): The set of possible responses to the query, which is always equal to [-1, 0, 1]
            where -1 represents the `About Equal` option.
        
    Raises:
        AssertionError: if slate does not have exactly 2 trajectories.
    """
    def __init__(self, slate: Union[TrajectorySet, List[Trajectory]]):
        super(WeakComparisonQuery, self).__init__()
        assert isinstance(slate, TrajectorySet) or isinstance(slate, list), 'Query constructor requires a TrajectorySet object for the slate.'
        self.slate = slate
        assert(self.K == 2), 'Weak comparison queries can only be pairwise comparisons, but ' + str(self.K) + ' trajectories were given.'
    
    @property
    def slate(self) -> TrajectorySet:
        """Returns a :class:`.TrajectorySet` of the trajectories in the query."""
        return self._slate
    
    @slate.setter
    def slate(self, new_slate: Union[TrajectorySet, List[Trajectory]]):
        """Sets the slate of trajectories in the query."""
        self._slate = new_slate if isinstance(new_slate, TrajectorySet) else TrajectorySet(new_slate)
        self.K = self._slate.size
        self.response_set = np.array([-1,0,1])

    def visualize(self, delay: float = 0.) -> int:
        """Visualizes the query and interactively asks for a response.
        
        Args:
            delay (float): The waiting time between each trajectory visualization in seconds.
            
        Returns:
            int: The response of the user.
        """
        for i in range(self.K):
            print('Playing trajectory #' + str(i))
            time.sleep(delay)
            self.slate[i].visualize()
        selection = None
        while selection is None:
            selection = input('Which trajectory is the best? Enter a number (-1 for "About Equal"): ')
            if not isinteger(selection) or int(selection) not in self.response_set:
                selection = None
        return int(selection)


class WeakComparison(QueryWithResponse):
    """
    A Weak Comparison feedback.
    
    Contains the :class:`.WeakComparisonQuery` the user responded to and the response.
    
    Parameters:
        query (WeakComparisonQuery): The query for which the feedback was given.
        response (int): The response of the user to the query.
        
    Attributes:
        response (int): The response of the user to the query.
        
    Raises:
        AssertionError: if the response is not in the response set of the query.
    """
    def __init__(self, query: WeakComparisonQuery, response: int):
        super(WeakComparison, self).__init__(query, response)
        assert(response in self.query.response_set), 'Invalid response ' + str(response) +  ' for the weak comparison query.'
        self.response = response


class FullRankingQuery(Query):
    """
    A full ranking query is one where the user is presented with multiple trajectories and asked for a ranking from their most 
    preferred trajectory to the least.
    
    Parameters:
        slate (TrajectorySet or List[Trajectory]): The set of trajectories that will be presented to the user.

    Attributes:
        K (int): The number of trajectories in the query.
        response_set (numpy.array): The set of possible responses to the query, which is all :py:attr:`K`-combinations of the 
            trajectory indices in the slate.
        
    Raises:
        AssertionError: if slate has less than 2 trajectories.
    """
    def __init__(self, slate: Union[TrajectorySet, List[Trajectory]]):
        super(FullRankingQuery, self).__init__()
        assert isinstance(slate, TrajectorySet) or isinstance(slate, list), 'Query constructor requires a TrajectorySet object for the slate.'
        self.slate = slate
        assert(self.K >= 2), 'Ranking queries have to include at least 2 trajectories.'
    
    @property
    def slate(self) -> TrajectorySet:
        """Returns a :class:`.TrajectorySet` of the trajectories in the query."""
        return self._slate
    
    @slate.setter
    def slate(self, new_slate: Union[TrajectorySet, List[Trajectory]]):
        """Sets the slate of trajectories in the query."""
        self._slate = new_slate if isinstance(new_slate, TrajectorySet) else TrajectorySet(new_slate)
        self.K = self._slate.size
        self.response_set = np.array([list(tup) for tup in itertools.permutations(np.arange(self.K))])

    def visualize(self, delay: float = 0.) -> List[int]:
        """Visualizes the query and interactively asks for a response.
        
        Args:
            delay (float): The waiting time between each trajectory visualization in seconds.
            
        Returns:
            List[int]: The response of the user, as a list from the most preferred to the least.
        """
        for i in range(self.K):
            print('Playing trajectory #' + str(i))
            time.sleep(delay)
            self.slate[i].visualize()
        response = []
        i = 1
        while i < self.K:
            selection = None
            while selection is None:
                selection = input('Which trajectory is your #' + str(i) + ' favorite? Enter a number [0-' + str(self.K-1) + ']: ')
                if not isinteger(selection) or int(selection) < 0 or int(selection) >= self.K:
                    selection = None
                elif int(selection) in response:
                    print('You have already chosen trajectory ' + selection + ' before!')
                    selection = None
            response.append(int(selection))
            i += 1
        remaining_id = np.setdiff1d(self.response_set, response)
        response.append(remaining_id.item())
        return np.array(response)


class FullRanking(QueryWithResponse):
    """
    A Full Ranking feedback.
    
    Contains the :class:`.FullRankingQuery` the user responded to and the response.
    
    Parameters:
        query (FullRankingQuery): The query for which the feedback was given.
        response (numpy.array): The response of the user to the query, indices from the most preferred to the least.
        
    Attributes:
        response (numpy.array): The response of the user to the query, indices from the most preferred to the least.
        
    Raises:
        AssertionError: if the response is not in the response set of the query.
    """
    def __init__(self, query: FullRankingQuery, response: List[int]):
        super(FullRanking, self).__init__(query)
        assert(response in self.query.response_set), 'Invalid response ' + str(response) + ' for the ranking query of size ' + str(self.query.K) + '.'
        self.response = response


def isinteger(input: str) -> bool:
    """Returns whether input is an integer.
    
    :Note: This function returns False if input is a string of a float, e.g., '3.0'.
    :TODO: Should this go to utils?
    
    Args:
        input (str): The string to be checked for being an integer.
    
    Returns:
        bool: True if the :py:attr:`input` is an integer, False otherwise.
    
    Raises:
        AssertionError: if the input is not a string.
    """
    assert(isinstance(input, str)), 'Invalid input to the isinteger method. The input must be a string.'
    try:
        a = int(input)
        return True
    except:
        return False