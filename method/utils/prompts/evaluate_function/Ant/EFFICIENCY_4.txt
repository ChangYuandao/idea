import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract relevant data for efficiency comparison
        # Joint velocities (measures energy from movement)
        dof_vel_a = state_a_info['dof_vel'][:, 3]  # Using the required indexing
        dof_vel_b = state_b_info['dof_vel'][:, 3]
        
        # Contact forces (measures energy loss through contact)
        contact_forces_a = state_a_info['vec_sensor_tensor'][:, 3]  # Using the required indexing
        contact_forces_b = state_b_info['vec_sensor_tensor'][:, 3]
        
        # Root velocity (forward motion efficiency)
        root_vel_a = state_a_info['root_states'][:, 7:10]  # Linear velocity components
        root_vel_b = state_b_info['root_states'][:, 7:10]
        
        # Actions (control effort - magnitude of control signals)
        actions_a = state_a_info['actions'][:, 3]  # Using the required indexing
        actions_b = state_b_info['actions'][:, 3]

        # Calculate metrics for efficiency comparison
        # Joint velocity magnitude (lower is more efficient)
        joint_vel_mag_a = np.sum(np.abs(dof_vel_a))
        joint_vel_mag_b = np.sum(np.abs(dof_vel_b))
        
        # Contact force magnitude (lower indicates less energy loss to environment)
        contact_mag_a = np.sum(np.abs(contact_forces_a))
        contact_mag_b = np.sum(np.abs(contact_forces_b))
        
        # Control effort (lower is more efficient)
        control_effort_a = np.sum(np.abs(actions_a))
        control_effort_b = np.sum(np.abs(actions_b))
        
        # Forward velocity (higher is better, but we want to balance with energy)
        forward_vel_a = np.abs(root_vel_a[0, 0])  # x-component (forward)
        forward_vel_b = np.abs(root_vel_b[0, 0])

        # Calculate efficiency metrics - lower values indicate better efficiency
        # We consider the energy expenditure relative to forward progress
        efficiency_a = joint_vel_mag_a + contact_mag_a + control_effort_a
        efficiency_b = joint_vel_mag_b + contact_mag_b + control_effort_b

        # Compare the efficiency metrics
        # State a is better if it has lower energy expenditure (more efficient)
        if efficiency_a < efficiency_b:
            label_list.append(1)  # A is more efficient
        elif efficiency_a > efficiency_b:
            label_list.append(-1)  # B is more efficient
        else:
            label_list.append(0)  # Equal efficiency

    return label_list