import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract root states for both trajectories
        # root_states format: [x, y, z, qx, qy, qz, qw, vx, vy, vz, avx, avy, avz]
        root_states_a = state_a_info['root_states']
        root_states_b = state_b_info['root_states']
        
        # Extract angular velocities (indices 10:13)
        ang_vel_a = root_states_a[:, 10:13]  # Shape: (num_ants, 3)
        ang_vel_b = root_states_b[:, 10:13]  # Shape: (num_ants, 3)
        
        # Compute magnitude of angular velocity (indicates rolling/tipping instability)
        ang_vel_mag_a = np.linalg.norm(ang_vel_a, axis=1)  # Shape: (num_ants,)
        ang_vel_mag_b = np.linalg.norm(ang_vel_b, axis=1)  # Shape: (num_ants,)
        
        # Extract up vector to assess posture stability
        up_vec_a = state_a_info['up_vec']  # Shape: (num_ants, 3)
        up_vec_b = state_b_info['up_vec']  # Shape: (num_ants, 3)
        
        # Compute how much the up vector deviates from the reference up direction (z-axis for up_axis_idx=2)
        # For up_axis_idx=2, the expected up vector is [0, 0, 1], so we look at the z-component
        up_proj_a = up_vec_a[:, 2]  # Z-component of up vector
        up_proj_b = up_vec_b[:, 2]  # Z-component of up vector
        
        # Extract DOF velocities to check for violent joint movements
        dof_vel_a = state_a_info['dof_vel']  # Shape: (num_ants, num_dofs)
        dof_vel_b = state_b_info['dof_vel']  # Shape: (num_ants, num_dofs)
        
        # Compute magnitude of DOF velocities (indicates violent joint movements)
        dof_vel_mag_a = np.linalg.norm(dof_vel_a, axis=1)  # Shape: (num_ants,)
        dof_vel_mag_b = np.linalg.norm(dof_vel_b, axis=1)  # Shape: (num_ants,)
        
        # Extract contact forces to assess ground impacts
        contact_forces_a = state_a_info['vec_sensor_tensor']  # Shape: (num_ants, 24)
        contact_forces_b = state_b_info['vec_sensor_tensor']  # Shape: (num_ants, 24)
        
        # Compute magnitude of contact forces (indicates impact with ground)
        contact_force_mag_a = np.linalg.norm(contact_forces_a, axis=1)  # Shape: (num_ants,)
        contact_force_mag_b = np.linalg.norm(contact_forces_b, axis=1)  # Shape: (num_ants,)
        
        # Evaluate stability metrics - lower values indicate better stability
        # 1. Angular velocity magnitude (lower is more stable)
        # 2. Up projection closer to 1.0 (more upright)
        # 3. DOF velocity magnitude (lower indicates smoother movements)
        # 4. Contact force magnitude (lower indicates less impact)
        
        # Lower angular velocity magnitude is safer
        ang_vel_better_a = ang_vel_mag_a <= ang_vel_mag_b
        
        # Higher up projection is safer (more upright)
        up_proj_better_a = up_proj_a >= up_proj_b
        
        # Lower DOF velocity magnitude is safer
        dof_vel_better_a = dof_vel_mag_a <= dof_vel_mag_b
        
        # Lower contact force magnitude is safer
        contact_force_better_a = contact_force_mag_a <= contact_force_mag_b
        
        # State A is better if it has better or equal values in ALL safety metrics
        if np.all(ang_vel_better_a) and np.all(up_proj_better_a) and np.all(dof_vel_better_a) and np.all(contact_force_better_a):
            label_list.append(1)
        # State B is better if it has better or equal values in ALL safety metrics
        elif np.all(~ang_vel_better_a) and np.all(~up_proj_better_a) and np.all(~dof_vel_better_a) and np.all(~contact_force_better_a):
            label_list.append(-1)
        else:
            # If neither trajectory is definitively better in all metrics, mark as equal
            label_list.append(0)

    return label_list