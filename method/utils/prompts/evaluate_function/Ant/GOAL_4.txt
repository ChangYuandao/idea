import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract root states (position and velocity)
        root_states_a = state_a_info['root_states'][:, 3:]  # Skip position for velocity
        root_states_b = state_b_info['root_states'][:, 3:]  # Skip position for velocity
        
        # Extract forward velocity (x-component of linear velocity)
        # Velocity is in root_states[:, 7:10], forward is index 7 (x-direction)
        forward_vel_a = state_a_info['root_states'][:, 7]  # x-velocity component
        forward_vel_b = state_b_info['root_states'][:, 7]  # x-velocity component
        
        # Extract position for displacement calculation
        pos_a = state_a_info['root_states'][:, 0:3]  # x, y, z positions
        pos_b = state_b_info['root_states'][:, 0:3]  # x, y, z positions
        
        # Calculate forward displacement (x-direction displacement)
        forward_disp_a = pos_a[:, 0]  # x position component
        forward_disp_b = pos_b[:, 0]  # x position component
        
        # Calculate heading projection to check forward alignment
        heading_proj_a = state_a_info['heading_vec'][:, 0]  # x-component of heading
        heading_proj_b = state_b_info['heading_vec'][:, 0]  # x-component of heading

        # Compare metrics: higher forward velocity, higher forward displacement, better heading alignment
        if (forward_vel_a >= forward_vel_b and 
            forward_disp_a >= forward_disp_b and 
            heading_proj_a >= heading_proj_b):
            label_list.append(1)
        elif (forward_vel_a <= forward_vel_b and 
              forward_disp_a <= forward_disp_b and 
              heading_proj_a <= heading_proj_b):
            label_list.append(-1)
        else:
            label_list.append(0)

    return label_list