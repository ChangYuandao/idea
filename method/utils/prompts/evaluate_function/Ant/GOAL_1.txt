import numpy as np
def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract root states for both trajectories
        # root_states contains [pos_x, pos_y, pos_z, quat_x, quat_y, quat_z, quat_w, vel_x, vel_y, vel_z, ang_vel_x, ang_vel_y, ang_vel_z]
        root_states_a = state_a_info['root_states'][:, 3:] if state_a_info['root_states'].shape[1] > 3 else state_a_info['root_states']
        root_states_b = state_b_info['root_states'][:, 3:] if state_b_info['root_states'].shape[1] > 3 else state_b_info['root_states']

        # Extract forward velocity (x-component of linear velocity)
        # Velocity components are at indices 7:10 in root_states [vel_x, vel_y, vel_z]
        if root_states_a.shape[1] >= 10:
            vel_a = root_states_a[:, 7:10]  # [vel_x, vel_y, vel_z]
            vel_b = root_states_b[:, 7:10]  # [vel_x, vel_y, vel_z]
            
            forward_vel_a = vel_a[:, 0]  # x-component (forward direction)
            forward_vel_b = vel_b[:, 0]  # x-component (forward direction)
        else:
            # If velocity not available in root_states, derive from potential changes
            potentials_a = state_a_info.get('potentials', np.zeros((1,)))
            potentials_b = state_b_info.get('potentials', np.zeros((1,)))
            prev_potentials_a = state_a_info.get('prev_potentials', np.zeros((1,)))
            prev_potentials_b = state_b_info.get('prev_potentials', np.zeros((1,)))
            
            # Calculate change in potential (related to forward progress)
            potential_change_a = potentials_a - prev_potentials_a
            potential_change_b = potentials_b - prev_potentials_b
            
            forward_vel_a = potential_change_a
            forward_vel_b = potential_change_b

        # Extract position for displacement calculation
        # Position components are at indices 0:3 in root_states [pos_x, pos_y, pos_z]
        if root_states_a.shape[1] >= 3:
            pos_a = root_states_a[:, 0:3]  # [pos_x, pos_y, pos_z]
            pos_b = root_states_b[:, 0:3]  # [pos_x, pos_y, pos_z]
            
            forward_pos_a = pos_a[:, 0]  # x-component (forward direction)
            forward_pos_b = pos_b[:, 0]  # x-component (forward direction)
        else:
            forward_pos_a = np.zeros_like(forward_vel_a)
            forward_pos_b = np.zeros_like(forward_vel_b)

        # Calculate forward distance along desired direction
        # Use potential as a proxy for forward progress (more negative potential = further from start)
        potentials_a = state_a_info.get('potentials', np.zeros((1,)))
        potentials_b = state_b_info.get('potentials', np.zeros((1,)))
        
        # More negative potential means further from target (or further in forward direction in some contexts)
        # So higher potential value (less negative) could mean closer to target
        # But for forward running, we want to maximize forward distance
        forward_distance_a = -potentials_a  # Convert to positive distance
        forward_distance_b = -potentials_b  # Convert to positive distance

        # Calculate metrics for comparison
        # Higher forward velocity is better
        # Higher forward position is better (further forward)
        # Higher forward distance based on potential is better
        
        # Compare metrics
        if (forward_vel_a >= forward_vel_b and 
            forward_pos_a >= forward_pos_b and 
            forward_distance_a >= forward_distance_b):
            label_list.append(1)
        elif (forward_vel_a <= forward_vel_b and 
              forward_pos_a <= forward_pos_b and 
              forward_distance_a <= forward_distance_b):
            label_list.append(-1)
        else:
            label_list.append(0)

    return label_list