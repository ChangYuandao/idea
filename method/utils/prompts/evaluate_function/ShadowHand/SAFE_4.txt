import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract object pose and goal pose information
        object_pos_a = state_a_info['object_pos'][:, 0:3]  # shape (1, 3)
        object_pos_b = state_b_info['object_pos'][:, 0:3]  # shape (1, 3)
        
        object_rot_a = state_a_info['object_rot'][:, 3:7]  # quaternion (w, x, y, z) format
        object_rot_b = state_b_info['object_rot'][:, 3:7]  # quaternion (w, x, y, z) format
        
        goal_pos_a = state_a_info['goal_pos'][:, 0:3]  # shape (1, 3)
        goal_pos_b = state_b_info['goal_pos'][:, 0:3]  # shape (1, 3)
        
        goal_rot_a = state_a_info['goal_rot'][:, 3:7]  # quaternion (w, x, y, z) format
        goal_rot_b = state_b_info['goal_rot'][:, 3:7]  # quaternion (w, x, y, z) format

        # Calculate orientation error (safety consideration: how close to target orientation)
        # Using quaternion dot product to measure orientation similarity
        # Higher dot product means more similar orientations (safer path toward target)
        dot_prod_a = np.sum(object_rot_a * goal_rot_a, axis=1)  # shape (1,)
        dot_prod_b = np.sum(object_rot_b * goal_rot_b, axis=1)  # shape (1,)
        
        # Calculate object position error (safety consideration: how stable the object position is)
        # Smaller distance to goal means safer trajectory
        pos_dist_a = np.linalg.norm(object_pos_a - goal_pos_a, axis=1)  # shape (1,)
        pos_dist_b = np.linalg.norm(object_pos_b - goal_pos_b, axis=1)  # shape (1,)

        # Calculate object linear velocity (safety consideration: how stable the object movement is)
        # Smaller velocity means safer trajectory
        object_linvel_a = state_a_info['object_linvel'][:, 0:3]  # shape (1, 3)
        object_linvel_b = state_b_info['object_linvel'][:, 0:3]  # shape (1, 3)
        linvel_mag_a = np.linalg.norm(object_linvel_a, axis=1)  # shape (1,)
        linvel_mag_b = np.linalg.norm(object_linvel_b, axis=1)  # shape (1,)

        # Calculate object angular velocity (safety consideration: how stable the rotation is)
        # Smaller angular velocity means safer trajectory
        object_angvel_a = state_a_info['object_angvel'][:, 0:3]  # shape (1, 3)
        object_angvel_b = state_b_info['object_angvel'][:, 0:3]  # shape (1, 3)
        angvel_mag_a = np.linalg.norm(object_angvel_a, axis=1)  # shape (1,)
        angvel_mag_b = np.linalg.norm(object_angvel_b, axis=1)  # shape (1,)

        # For safety evaluation:
        # 1. Higher orientation similarity (dot product) is safer
        # 2. Smaller position distance is safer
        # 3. Smaller linear velocity is safer
        # 4. Smaller angular velocity is safer

        # State A is safer if it has higher orientation similarity AND smaller position distance AND smaller velocities
        if (dot_prod_a >= dot_prod_b and 
            pos_dist_a <= pos_dist_b and 
            linvel_mag_a <= linvel_mag_b and 
            angvel_mag_a <= angvel_mag_b):
            label_list.append(1)
        # State B is safer if it has higher orientation similarity AND smaller position distance AND smaller velocities
        elif (dot_prod_a <= dot_prod_b and 
              pos_dist_a >= pos_dist_b and 
              linvel_mag_a >= linvel_mag_b and 
              angvel_mag_a >= angvel_mag_b):
            label_list.append(-1)
        else:
            label_list.append(0)

    return label_list