import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract object and goal positions and rotations for both trajectories
        object_pos_a = state_a_info['object_pos'][:, :3]  # shape (1, 3)
        object_rot_a = state_a_info['object_rot'][:, :4]  # shape (1, 4)
        goal_pos_a = state_a_info['goal_pos'][:, :3]      # shape (1, 3)
        goal_rot_a = state_a_info['goal_rot'][:, :4]      # shape (1, 4)

        object_pos_b = state_b_info['object_pos'][:, :3]  # shape (1, 3)
        object_rot_b = state_b_info['object_rot'][:, :4]  # shape (1, 4)
        goal_pos_b = state_b_info['goal_pos'][:, :3]      # shape (1, 3)
        goal_rot_b = state_b_info['goal_rot'][:, :4]      # shape (1, 4)

        # Calculate the orientation distance (angular difference) between object and goal
        # Using quaternion dot product to measure orientation similarity
        # Dot product of quaternions gives cosine of half the rotation angle
        dot_product_a = np.sum(object_rot_a * goal_rot_a, axis=1)  # shape (1,)
        dot_product_b = np.sum(object_rot_b * goal_rot_b, axis=1)  # shape (1,)
        
        # Take absolute value to account for quaternion double-cover (q and -q represent same rotation)
        dot_product_a = np.abs(dot_product_a)
        dot_product_b = np.abs(dot_product_b)
        
        # Convert to angular distance (smaller angular distance means better alignment)
        # Since we want to compare distances, we can use 1 - abs(dot_product) as a distance metric
        # (1 - abs(dot_product)) will be smaller when the quaternions are more aligned
        orientation_distance_a = 1.0 - dot_product_a  # shape (1,)
        orientation_distance_b = 1.0 - dot_product_b  # shape (1,)

        # Calculate the position distance between object and goal
        pos_dist_a = np.linalg.norm(object_pos_a - goal_pos_a, axis=1)  # shape (1,)
        pos_dist_b = np.linalg.norm(object_pos_b - goal_pos_b, axis=1)  # shape (1,)

        # Compare the metrics
        # For both orientation and position, smaller distance is better
        if orientation_distance_a[0] <= orientation_distance_b[0] and pos_dist_a[0] <= pos_dist_b[0]:
            label_list.append(1)  # A is better
        elif orientation_distance_a[0] >= orientation_distance_b[0] and pos_dist_a[0] >= pos_dist_b[0]:
            label_list.append(-1)  # B is better
        else:
            label_list.append(0)  # Neither is clearly better

    return label_list