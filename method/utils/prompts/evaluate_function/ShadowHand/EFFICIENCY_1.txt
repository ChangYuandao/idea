import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract object and goal positions and rotations
        object_pos_a = state_a_info['object_pos'][:, :3]  # shape (N, 3)
        object_rot_a = state_a_info['object_rot'][:, :4]  # shape (N, 4)
        goal_pos_a = state_a_info['goal_pos'][:, :3]      # shape (N, 3)
        goal_rot_a = state_a_info['goal_rot'][:, :4]      # shape (N, 4)

        object_pos_b = state_b_info['object_pos'][:, :3]  # shape (N, 3)
        object_rot_b = state_b_info['object_rot'][:, :4]  # shape (N, 4)
        goal_pos_b = state_b_info['goal_pos'][:, :3]      # shape (N, 3)
        goal_rot_b = state_b_info['goal_rot'][:, :4]      # shape (N, 4)

        # Calculate distance from object to goal position
        dist_to_goal_a = np.linalg.norm(object_pos_a - goal_pos_a, axis=1)  # shape (N,)
        dist_to_goal_b = np.linalg.norm(object_pos_b - goal_pos_b, axis=1)  # shape (N,)

        # Calculate orientation distance (angle difference between object and goal rotations)
        # Using dot product to measure alignment (higher is better alignment)
        # Note: This assumes normalized quaternions
        orientation_alignment_a = np.abs(np.sum(object_rot_a * goal_rot_a, axis=1))  # shape (N,)
        orientation_alignment_b = np.abs(np.sum(object_rot_b * goal_rot_b, axis=1))  # shape (N,)
        
        # Convert alignment to distance (lower is better alignment)
        orientation_dist_a = 1.0 - orientation_alignment_a
        orientation_dist_b = 1.0 - orientation_alignment_b

        # Calculate object angular velocity magnitude
        object_angvel_a = state_a_info['object_angvel'][:, :3]  # shape (N, 3)
        object_angvel_b = state_b_info['object_angvel'][:, :3]  # shape (N, 3)
        
        angvel_magnitude_a = np.linalg.norm(object_angvel_a, axis=1)  # shape (N,)
        angvel_magnitude_b = np.linalg.norm(object_angvel_b, axis=1)  # shape (N,)

        # Calculate fingertip positions for both trajectories
        fingertip_pos_a = state_a_info['fingertip_pos']  # shape (N, num_fingertips, 3)
        fingertip_pos_b = state_b_info['fingertip_pos']  # shape (N, num_fingertips, 3)

        # Calculate distance from fingertips to object for both trajectories
        # Reshape object_pos to broadcast with fingertip_pos
        object_pos_a_expanded = np.expand_dims(object_pos_a, axis=1)  # shape (N, 1, 3)
        object_pos_b_expanded = np.expand_dims(object_pos_b, axis=1)  # shape (N, 1, 3)

        # Calculate distances from each fingertip to the object
        dist_fingertip_to_object_a = np.linalg.norm(fingertip_pos_a - object_pos_a_expanded, axis=2)  # shape (N, num_fingertips)
        dist_fingertip_to_object_b = np.linalg.norm(fingertip_pos_b - object_pos_b_expanded, axis=2)  # shape (N, num_fingertips)

        # Use the minimum distance from any fingertip to the object as a metric
        min_dist_fingertip_to_object_a = np.min(dist_fingertip_to_object_a, axis=1)  # shape (N,)
        min_dist_fingertip_to_object_b = np.min(dist_fingertip_to_object_b, axis=1)  # shape (N,)

        # For efficiency evaluation in spinning task, we want:
        # 1. Lower orientation distance (better alignment with target)
        # 2. Lower position distance (object closer to goal position)
        # 3. Lower fingertip-to-object distance (better contact/grasp)
        # 4. Higher angular velocity magnitude (faster spinning)

        # Check if state A is better than state B in all metrics
        orientation_better_a = orientation_dist_a < orientation_dist_b
        position_better_a = dist_to_goal_a < dist_to_goal_b
        contact_better_a = min_dist_fingertip_to_object_a < min_dist_fingertip_to_object_b
        spinning_better_a = angvel_magnitude_a > angvel_magnitude_b  # Higher is better for spinning

        # Check if state B is better than state A in all metrics
        orientation_better_b = orientation_dist_a > orientation_dist_b
        position_better_b = dist_to_goal_a > dist_to_goal_b
        contact_better_b = min_dist_fingertip_to_object_a > min_dist_fingertip_to_object_b
        spinning_better_b = angvel_magnitude_a < angvel_magnitude_b  # Higher is better for spinning

        if orientation_better_a and position_better_a and contact_better_a and spinning_better_a:
            label_list.append(1)
        elif orientation_better_b and position_better_b and contact_better_b and spinning_better_b:
            label_list.append(-1)
        else:
            label_list.append(0)

    return label_list