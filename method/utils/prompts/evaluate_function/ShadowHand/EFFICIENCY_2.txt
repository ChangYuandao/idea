import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract object and goal positions and rotations
        object_pos_a = state_a_info['object_pos'][:, :3]  # shape: (batch, 3)
        object_pos_b = state_b_info['object_pos'][:, :3]  # shape: (batch, 3)
        
        object_rot_a = state_a_info['object_rot'][:, :4]  # shape: (batch, 4) - quaternion
        object_rot_b = state_b_info['object_rot'][:, :4]  # shape: (batch, 4) - quaternion
        
        goal_pos_a = state_a_info['goal_pos'][:, :3]  # shape: (batch, 3)
        goal_pos_b = state_b_info['goal_pos'][:, :3]  # shape: (batch, 3)
        
        goal_rot_a = state_a_info['goal_rot'][:, :4]  # shape: (batch, 4) - quaternion
        goal_rot_b = state_b_info['goal_rot'][:, :4]  # shape: (batch, 4) - quaternion
        
        fingertip_pos_a = state_a_info['fingertip_pos']  # shape: (batch, num_fingertips, 3)
        fingertip_pos_b = state_b_info['fingertip_pos']  # shape: (batch, num_fingertips, 3)

        # Calculate distance from object to goal position
        obj_to_goal_dist_a = np.linalg.norm(object_pos_a - goal_pos_a, axis=1)
        obj_to_goal_dist_b = np.linalg.norm(object_pos_b - goal_pos_b, axis=1)

        # Calculate orientation difference (using dot product between quaternions)
        # For quaternions q1 and q2, the dot product gives cosine of half the angle between them
        # The closer the absolute value is to 1, the smaller the rotation difference
        orientation_diff_a = 1 - np.abs(np.sum(object_rot_a * goal_rot_a, axis=1))
        orientation_diff_b = 1 - np.abs(np.sum(object_rot_b * goal_rot_b, axis=1))

        # Calculate average distance from fingertips to object (to measure manipulation contact)
        # Reshape object_pos to (batch, 1, 3) to broadcast with fingertip_pos (batch, num_fingertips, 3)
        obj_pos_expanded_a = np.expand_dims(object_pos_a, axis=1)  # (batch, 1, 3)
        obj_pos_expanded_b = np.expand_dims(object_pos_b, axis=1)  # (batch, 1, 3)
        
        fingertip_to_obj_dist_a = np.linalg.norm(fingertip_pos_a - obj_pos_expanded_a, axis=2)  # (batch, num_fingertips)
        fingertip_to_obj_dist_b = np.linalg.norm(fingertip_pos_b - obj_pos_expanded_b, axis=2)  # (batch, num_fingertips)
        
        avg_fingertip_to_obj_a = np.mean(fingertip_to_obj_dist_a, axis=1)
        avg_fingertip_to_obj_b = np.mean(fingertip_to_obj_dist_b, axis=1)

        # For efficiency evaluation, consider both position and orientation accuracy
        # A more efficient trajectory would have smaller distances to goal position and orientation
        # and appropriate fingertip-to-object distances indicating good manipulation
        if (obj_to_goal_dist_a < obj_to_goal_dist_b and 
            orientation_diff_a < orientation_diff_b and
            avg_fingertip_to_obj_a <= avg_fingertip_to_obj_b):
            label_list.append(1)
        elif (obj_to_goal_dist_a > obj_to_goal_dist_b and 
              orientation_diff_a > orientation_diff_b and
              avg_fingertip_to_obj_a >= avg_fingertip_to_obj_b):
            label_list.append(-1)
        else:
            label_list.append(0)

    return label_list