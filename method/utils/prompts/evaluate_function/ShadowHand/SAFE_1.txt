import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract object positions
        object_pos_a = state_a_info['object_pos'][:, :3]  # shape (n_envs, 3)
        object_pos_b = state_b_info['object_pos'][:, :3]  # shape (n_envs, 3)
        
        # Extract object orientations
        object_rot_a = state_a_info['object_rot'][:, :4]  # shape (n_envs, 4)
        object_rot_b = state_b_info['object_rot'][:, :4]  # shape (n_envs, 4)
        
        # Extract goal orientations
        goal_rot_a = state_a_info['goal_rot'][:, :4]  # shape (n_envs, 4)
        goal_rot_b = state_b_info['goal_rot'][:, :4]  # shape (n_envs, 4)
        
        # Extract fingertip positions
        fingertip_pos_a = state_a_info['fingertip_pos']  # shape (n_envs, n_fingertips, 3)
        fingertip_pos_b = state_b_info['fingertip_pos']  # shape (n_envs, n_fingertips, 3)
        
        # Calculate orientation error (distance between current and goal orientations)
        # Using quaternion dot product to measure similarity
        # For quaternions q1 and q2, similarity = |q1 Â· q2|
        dot_product_a = np.abs(np.sum(object_rot_a * goal_rot_a, axis=1))  # shape (n_envs,)
        dot_product_b = np.abs(np.sum(object_rot_b * goal_rot_b, axis=1))  # shape (n_envs,)
        
        # Convert to orientation error (smaller is better)
        orientation_error_a = 1 - np.clip(dot_product_a, -1.0, 1.0)  # shape (n_envs,)
        orientation_error_b = 1 - np.clip(dot_product_b, -1.0, 1.0)  # shape (n_envs,)
        
        # Calculate object velocity (magnitude of linear velocity)
        object_linvel_a = state_a_info['object_linvel'][:, :3]  # shape (n_envs, 3)
        object_linvel_b = state_b_info['object_linvel'][:, :3]  # shape (n_envs, 3)
        
        object_vel_a = np.linalg.norm(object_linvel_a, axis=1)  # shape (n_envs,)
        object_vel_b = np.linalg.norm(object_linvel_b, axis=1)  # shape (n_envs,)
        
        # Calculate angular velocity (magnitude of angular velocity)
        object_angvel_a = state_a_info['object_angvel'][:, :3]  # shape (n_envs, 3)
        object_angvel_b = state_b_info['object_angvel'][:, :3]  # shape (n_envs, 3)
        
        object_angvel_mag_a = np.linalg.norm(object_angvel_a, axis=1)  # shape (n_envs,)
        object_angvel_mag_b = np.linalg.norm(object_angvel_b, axis=1)  # shape (n_envs,)
        
        # Calculate fingertip-object distance (safety consideration: too far might indicate loss of control)
        # We'll compute the minimum distance from any fingertip to the object
        # Reshape object_pos to (n_envs, 1, 3) for broadcasting
        object_pos_a_expanded = np.expand_dims(object_pos_a, axis=1)  # shape (n_envs, 1, 3)
        object_pos_b_expanded = np.expand_dims(object_pos_b, axis=1)  # shape (n_envs, 1, 3)
        
        # Calculate distances from each fingertip to the object
        dist_fingertip_object_a = np.linalg.norm(fingertip_pos_a - object_pos_a_expanded, axis=2)  # shape (n_envs, n_fingertips)
        dist_fingertip_object_b = np.linalg.norm(fingertip_pos_b - object_pos_b_expanded, axis=2)  # shape (n_envs, n_fingertips)
        
        # Get minimum distance from any fingertip to the object
        min_dist_fingertip_object_a = np.min(dist_fingertip_object_a, axis=1)  # shape (n_envs,)
        min_dist_fingertip_object_b = np.min(dist_fingertip_object_b, axis=1)  # shape (n_envs,)
        
        # For safety evaluation, we consider:
        # 1. Lower orientation error is better (closer to target orientation)
        # 2. Lower object linear velocity is safer (more controlled)
        # 3. Lower object angular velocity is safer (more controlled)
        # 4. Reasonable fingertip-object distance (not too far to lose control)
        
        # For safety, we want lower orientation error, lower velocities, and reasonable fingertip distance
        # In terms of safety: lower values for orientation_error, object_vel, object_angvel_mag are better
        # For fingertip distance: we consider both too far and too close as potentially unsafe
        # But primarily we check that state a has better control metrics than state b
        
        # For orientation error, lower is safer (better control toward target)
        # For velocities, lower is safer
        # For fingertip distance, we consider the absolute distance but prioritize the other metrics
        
        # Compare metrics: lower values indicate better safety
        orientation_better_a = orientation_error_a < orientation_error_b
        linvel_better_a = object_vel_a < object_vel_b
        angvel_better_a = object_angvel_mag_a < object_angvel_mag_b
        
        # For fingertip distance, we check if both are in reasonable range but one is better
        # Since this is a safety evaluation, we want to ensure both are reasonably close
        # But we'll focus on the primary metrics for safety
        fingertip_dist_better_a = min_dist_fingertip_object_a < min_dist_fingertip_object_b
        
        # Evaluate if state a is safer than state b across all metrics
        if np.all(orientation_better_a) and np.all(linvel_better_a) and np.all(angvel_better_a):
            label_list.append(1)
        elif np.all(~orientation_better_a) and np.all(~linvel_better_a) and np.all(~angvel_better_a):
            label_list.append(-1)
        else:
            label_list.append(0)

    return label_list