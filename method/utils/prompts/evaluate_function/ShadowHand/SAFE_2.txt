import numpy as np

def trajectory_evaluate(trajectory_a, trajectory_b):
    """
    Both trajectory_a and trajectory_b are lists, each containing multiple states,
    and each state is represented as a dictionary.

    The label_list is a list of indices that corresponds to the states in the subtrajectory
    where A is definitively better or worse than B.

    The label indicates the quality of the sub-trajectory:
      - if A is better, the label is 1 ("Former")
      - if B is better, the label is -1 ("Latter")
      - if no valid sub-trajectory can be found between the two trajectories, label_list will be an empty list ([]).
    """
    traj_a_length = len(trajectory_a)
    traj_b_length = len(trajectory_b)
    assert traj_a_length == traj_b_length

    label_list = []

    for state_index in range(traj_a_length):
        state_a_info = trajectory_a[state_index]
        state_b_info = trajectory_b[state_index]

        # Extract object and goal poses for both trajectories
        object_pos_a = state_a_info['object_pos'][:, :3]  # shape: (num_envs, 3)
        object_rot_a = state_a_info['object_rot'][:, :4]  # shape: (num_envs, 4)
        goal_pos_a = state_a_info['goal_pos'][:, :3]      # shape: (num_envs, 3)
        goal_rot_a = state_a_info['goal_rot'][:, :4]      # shape: (num_envs, 4)
        
        object_pos_b = state_b_info['object_pos'][:, :3]  # shape: (num_envs, 3)
        object_rot_b = state_b_info['object_rot'][:, :4]  # shape: (num_envs, 4)
        goal_pos_b = state_b_info['goal_pos'][:, :3]      # shape: (num_envs, 3)
        goal_rot_b = state_b_info['goal_rot'][:, :4]      # shape: (num_envs, 4)

        # Calculate orientation difference (safety metric: how close to target orientation)
        # Compute quaternion difference between object and goal orientations
        # For quaternions q1 and q2, the difference is given by: q_diff = q1 * conj(q2)
        # We'll compute the scalar part of the relative rotation quaternion (cos of half angle)
        w1_a, x1_a, y1_a, z1_a = object_rot_a[:, 0], object_rot_a[:, 1], object_rot_a[:, 2], object_rot_a[:, 3]
        w2_a, x2_a, y2_a, z2_a = goal_rot_a[:, 0], goal_rot_a[:, 1], goal_rot_a[:, 2], goal_rot_a[:, 3]
        
        # Conjugate of goal rotation
        conj_w_a, conj_x_a, conj_y_a, conj_z_a = w2_a, -x2_a, -y2_a, -z2_a
        
        # Multiply object_rot * conj(goal_rot) to get relative rotation
        rel_w_a = w1_a * conj_w_a - x1_a * conj_x_a - y1_a * conj_y_a - z1_a * conj_z_a
        # We only need the scalar part to determine the angle difference
        # The scalar part of a quaternion is cos(angle/2), so closer to 1 means smaller angle
        
        w1_b, x1_b, y1_b, z1_b = object_rot_b[:, 0], object_rot_b[:, 1], object_rot_b[:, 2], object_rot_b[:, 3]
        w2_b, x2_b, y2_b, z2_b = goal_rot_b[:, 0], goal_rot_b[:, 1], goal_rot_b[:, 2], goal_rot_b[:, 3]
        
        # Conjugate of goal rotation
        conj_w_b, conj_x_b, conj_y_b, conj_z_b = w2_b, -x2_b, -y2_b, -z2_b
        
        # Multiply object_rot * conj(goal_rot) to get relative rotation
        rel_w_b = w1_b * conj_w_b - x1_b * conj_x_b - y1_b * conj_y_b - z1_b * conj_z_b

        # Calculate object position stability (safety metric: how stable the object position is)
        pos_dist_a = np.linalg.norm(object_pos_a - goal_pos_a, axis=1)  # Distance from object to goal position
        pos_dist_b = np.linalg.norm(object_pos_b - goal_pos_b, axis=1)  # Distance from object to goal position

        # Calculate object velocity (safety metric: how fast the object is moving)
        object_linvel_a = state_a_info['object_linvel'][:, :3]  # shape: (num_envs, 3)
        object_angvel_a = state_a_info['object_angvel'][:, :3]  # shape: (num_envs, 3)
        linvel_norm_a = np.linalg.norm(object_linvel_a, axis=1)
        angvel_norm_a = np.linalg.norm(object_angvel_a, axis=1)
        
        object_linvel_b = state_b_info['object_linvel'][:, :3]  # shape: (num_envs, 3)
        object_angvel_b = state_b_info['object_angvel'][:, :3]  # shape: (num_envs, 3)
        linvel_norm_b = np.linalg.norm(object_linvel_b, axis=1)
        angvel_norm_b = np.linalg.norm(object_angvel_b, axis=1)

        # For safety evaluation, we want:
        # 1. Orientation closer to target (rel_w closer to 1)
        # 2. Lower velocities (safer)
        # 3. More stable position (smaller pos_dist)

        # Check if trajectory A is safer across all metrics
        orientation_safer_a = rel_w_a >= rel_w_b  # Higher value means closer to target
        pos_stable_safer_a = pos_dist_a <= pos_dist_b  # Lower distance is safer
        linvel_safer_a = linvel_norm_a <= linvel_norm_b  # Lower velocity is safer
        angvel_safer_a = angvel_norm_a <= angvel_norm_b  # Lower angular velocity is safer

        # Trajectory A is safer if it's better in ALL metrics
        if orientation_safer_a.all() and pos_stable_safer_a.all() and linvel_safer_a.all() and angvel_safer_a.all():
            label_list.append(1)
        # Check if trajectory B is safer across all metrics
        elif orientation_safer_a.all() == False and pos_stable_safer_a.all() == False and linvel_safer_a.all() == False and angvel_safer_a.all() == False:
            # Actually check B is better in all metrics
            orientation_safer_b = rel_w_b >= rel_w_a
            pos_stable_safer_b = pos_dist_b <= pos_dist_a
            linvel_safer_b = linvel_norm_b <= linvel_norm_a
            angvel_safer_b = angvel_norm_b <= angvel_norm_a
            
            if orientation_safer_b.all() and pos_stable_safer_b.all() and linvel_safer_b.all() and angvel_safer_b.all():
                label_list.append(-1)
        else:
            # If neither trajectory is better in all metrics, they are equal
            label_list.append(0)

    return label_list